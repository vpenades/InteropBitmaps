<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace InteropTensors
{
    <# var TDIM_MAX = 8; #>

    <# for(var TDIMCOUNT = 1; TDIMCOUNT <= TDIM_MAX; ++TDIMCOUNT) { #>
    <# var TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int i{idx}")); #>

    /// <summary>
    /// Represents the indices of a specific element within a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TensorIndices<#= TDIMCOUNT#> : IReadOnlyList<int>, IEquatable<TensorIndices<#= TDIMCOUNT#>>
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }        

        #endregion

        #region lifecycle

        public static implicit operator TensorIndices<#= TDIMCOUNT#>(ReadOnlySpan<int> indices)
        {
            return new TensorIndices<#= TDIMCOUNT#>(indices);
        }        

        <# if (TDIMCOUNT == 1) { #>        

        <# } else { #>

        public static implicit operator TensorIndices<#= TDIMCOUNT#>(in (<#= TARGS#>) indices)
        {
            return new TensorIndices<#= TDIMCOUNT#>(indices);
        }

        public TensorIndices<#= TDIMCOUNT#>(in (<#= TARGS#>) indices)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = indices.i<#= TDIM#>;
            <# } #>

        }

        <# } #>

        public TensorIndices<#= TDIMCOUNT#>(<#= TARGS#>)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = i<#= TDIM#>;
            <# } #>

        }

        public TensorIndices<#= TDIMCOUNT#>(ReadOnlySpan<int> indices)
        {
            if (indices.Length != <#= TDIMCOUNT#>) throw new ArgumentOutOfRangeException(nameof(indices));

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = indices[<#= TDIM#>];
            <# } #>

        }

        public TensorIndices<#= TDIMCOUNT#>(IReadOnlyList<int> indices)
        {
            if (indices.Count != <#= TDIMCOUNT#>) throw new ArgumentOutOfRangeException(nameof(indices));

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = indices[<#= TDIM#>];
            <# } #>

        }        

        #endregion

        #region data

        <# if (TDIMCOUNT == 1) { #>

        <# } else { #>

        <# var TNEGXX = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => "-1")); #>
public static readonly TensorIndices<#= TDIMCOUNT#> Invalid = (<#= TNEGXX#>);

        <# } #>

        <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> public int Index<#= TDIM#>;
        <# } #>

        public override int GetHashCode()
        {
            int h=0;

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> h ^= Index<#= TDIM#>.GetHashCode(); h *=17;
            <# } #>

            return h;
        }

        public static bool AreEqual(in TensorIndices<#= TDIMCOUNT#> a, in TensorIndices<#= TDIMCOUNT#> b)
        {            
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> if (a.Index<#= TDIM#> != b.Index<#= TDIM#>) return false;
            <# } #>

            return true;
        }

        public static bool operator ==(in TensorIndices<#= TDIMCOUNT#> a, in TensorIndices<#= TDIMCOUNT#> b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorIndices<#= TDIMCOUNT#> a, in TensorIndices<#= TDIMCOUNT#> b) { return !AreEqual(a,b); }

        public bool Equals(TensorIndices<#= TDIMCOUNT#> other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorIndices<#= TDIMCOUNT#> other ? AreEqual(this, other) : false; }

        #endregion        

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => <#= TDIMCOUNT#>;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #>
        case <#= TDIM#>: return Index<#= TDIM#>;
            <# } #>                    
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
        <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #>
    yield return Index<#= TDIM#>;
        <# } #>
}

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        <# var TITEMS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"Index{idx}")); #>
public int[] ToArray() { return new int[] { <#= TITEMS#> }; }        

        #endregion

        #region API - Other

        <# if (TDIMCOUNT == 1) { #>        

        <# } else { #>

        <#
        TITEMS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"Index{idx}"));        
        var TRESULT = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int Index{idx}"));        
        #>
public (<#= TRESULT#>) ToValueTuple() { return (<#= TITEMS#>); }

        <# } #>

        #endregion
    }

    <# } #>
}
